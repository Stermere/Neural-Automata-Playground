{
  "weights": [
    [
      [
        [
          1,
          1,
          1,
          1,
          1
        ],
        [
          1,
          0,
          0,
          0,
          1
        ],
        [
          1,
          0,
          0,
          0,
          1
        ],
        [
          1,
          0,
          0,
          0,
          1
        ],
        [
          1,
          1,
          1,
          1,
          1
        ]
      ],
      [
        [
          0,
          0,
          0,
          0,
          0
        ],
        [
          0,
          0,
          0,
          0,
          0
        ],
        [
          0,
          0,
          0,
          0,
          0
        ],
        [
          0,
          0,
          0,
          0,
          0
        ],
        [
          -1,
          0,
          0,
          0,
          -1
        ]
      ],
      [
        [
          0,
          0,
          0,
          0,
          0
        ],
        [
          0,
          0,
          0,
          0,
          0
        ],
        [
          0,
          0,
          0,
          0,
          0
        ],
        [
          0,
          0,
          0,
          0,
          0
        ],
        [
          0,
          0,
          0,
          0,
          0
        ]
      ]
    ],
    [
      [
        [
          0,
          0,
          0,
          0,
          3
        ],
        [
          0,
          0,
          5,
          0,
          0
        ],
        [
          0,
          -2,
          -10,
          5,
          0
        ],
        [
          0,
          0,
          -2,
          0,
          0
        ],
        [
          -1,
          0,
          0,
          0,
          0
        ]
      ],
      [
        [
          1,
          1,
          1,
          1,
          1
        ],
        [
          1,
          0,
          0,
          0,
          1
        ],
        [
          1,
          0,
          0,
          0,
          1
        ],
        [
          1,
          0,
          0,
          0,
          1
        ],
        [
          1,
          1,
          1,
          1,
          1
        ]
      ],
      [
        [
          5,
          5,
          2,
          0,
          0
        ],
        [
          -1,
          -1,
          2,
          -1,
          -1
        ],
        [
          0,
          0,
          2,
          0,
          0
        ],
        [
          -1,
          -1,
          2,
          -1,
          -1
        ],
        [
          0,
          0,
          2,
          0,
          0
        ]
      ]
    ],
    [
      [
        [
          5,
          5,
          2,
          0,
          0
        ],
        [
          -1,
          -1,
          2,
          -1,
          -1
        ],
        [
          0,
          0,
          2,
          0,
          0
        ],
        [
          -1,
          -1,
          2,
          -1,
          -1
        ],
        [
          0,
          0,
          2,
          0,
          0
        ]
      ],
      [
        [
          1,
          1,
          2,
          0,
          0
        ],
        [
          1,
          2,
          3,
          0,
          0
        ],
        [
          2,
          3,
          4,
          0,
          0
        ],
        [
          0,
          0,
          0,
          0,
          0
        ],
        [
          0,
          0,
          0,
          0,
          0
        ]
      ],
      [
        [
          1,
          1,
          1,
          1,
          1
        ],
        [
          1,
          0,
          0,
          0,
          0
        ],
        [
          1,
          0,
          0,
          0,
          0
        ],
        [
          1,
          0,
          0,
          0,
          0
        ],
        [
          1,
          1,
          1,
          1,
          1
        ]
      ]
    ]
  ],
  "activationCode": "// Mandelbrot fractal with fake 64-bit precision using double-single arithmetic\n// Each high-precision number is represented as hi + lo where hi contains\n// the most significant bits and lo contains the remaining precision\n\nstruct View {\n    zoom_hi: f32,\n    zoom_lo: f32,\n    centerTile: vec2<u32>,\n    centerFrac_hi: vec2<f32>,  // high parts of fractional position\n    centerFrac_lo: vec2<f32>   // low parts of fractional position\n};\n\nconst MAX_ITERATIONS: u32       = 1000u;\nconst ESCAPE_RADIUS_SQUARED: f32 = 4.0;\nconst ZOOM_SPEED: f32            = 0.0025;\nconst INITIAL_ZOOM: f32          = 0.01;\nconst PAN_SPEED: f32             = 0.01;\n\n// Initial + target pan centers (in full fp space)\nconst INIT_CENTER: vec2<f32>   = vec2<f32>(0, 0);\nconst TARGET_CENTER: vec2<f32> = vec2<f32>(-0.039016, 0.985599);\n\n// Safe fractional band\nconst SAFE_MIN: f32 = 0.25;\nconst SAFE_MAX: f32 = 0.75;\n\n// ===== DOUBLE-SINGLE ARITHMETIC FUNCTIONS =====\n\n// Normalize DS representation (ensures hi contains the most significant bits)\nfn ds_normalize(hi: f32, lo: f32) -> vec2<f32> {\n    let s = hi + lo;\n    let e = lo - (s - hi);\n    return vec2<f32>(s, e);\n}\n\n// DS addition: (a_hi + a_lo) + (b_hi + b_lo)\nfn ds_add(a_hi: f32, a_lo: f32, b_hi: f32, b_lo: f32) -> vec2<f32> {\n    let s1 = a_hi + b_hi;\n    let s2 = a_lo + b_lo;\n    let v = s1 - a_hi;\n    let u = s1 - v;\n    let w = a_hi - u;\n    let x = b_hi - v;\n    let y = w + x;\n    let z = y + s2;\n    return vec2<f32>(s1, z);\n}\n\n// DS subtraction\nfn ds_sub(a_hi: f32, a_lo: f32, b_hi: f32, b_lo: f32) -> vec2<f32> {\n    return ds_add(a_hi, a_lo, -b_hi, -b_lo);\n}\n\n// DS multiplication using Dekker's algorithm\nfn ds_mul(a_hi: f32, a_lo: f32, b_hi: f32, b_lo: f32) -> vec2<f32> {\n    let c11 = a_hi * b_hi;\n    let c21 = a_lo * b_hi;\n    let c12 = a_hi * b_lo;\n    let c22 = a_lo * b_lo;\n    \n    let t1 = c11;\n    let t2 = c21 + c12 + c22;\n    \n    return ds_normalize(t1, t2);\n}\n\n// DS multiplication by single float\nfn ds_mul_f(a_hi: f32, a_lo: f32, b: f32) -> vec2<f32> {\n    let c_hi = a_hi * b;\n    let c_lo = a_lo * b;\n    return ds_normalize(c_hi, c_lo);\n}\n\n// Mix function for DS numbers\nfn ds_mix(a_hi: f32, a_lo: f32, b_hi: f32, b_lo: f32, t: f32) -> vec2<f32> {\n    let one_minus_t = 1.0 - t;\n    let term1 = ds_mul_f(a_hi, a_lo, one_minus_t);\n    let term2 = ds_mul_f(b_hi, b_lo, t);\n    return ds_add(term1.x, term1.y, term2.x, term2.y);\n}\n\n// Floor function for DS\nfn ds_floor(a_hi: f32, a_lo: f32) -> vec2<f32> {\n    let f_hi = floor(a_hi);\n    var f_lo = 0.0;\n    if (f_hi == a_hi) {\n        f_lo = floor(a_lo);\n    }\n    return vec2<f32>(f_hi, f_lo);\n}\n\n// Fractional part for DS\nfn ds_fract(a_hi: f32, a_lo: f32) -> vec2<f32> {\n    let floor_result = ds_floor(a_hi, a_lo);\n    return ds_sub(a_hi, a_lo, floor_result.x, floor_result.y);\n}\n\n// Convert DS to single float\nfn ds_to_float(a_hi: f32, a_lo: f32) -> f32 {\n    return a_hi + a_lo;\n}\n\n// Convert DS to int (for tile indexing)\nfn ds_to_int(a_hi: f32, a_lo: f32) -> i32 {\n    return i32(a_hi + a_lo);\n}\n\n// ===== MANDELBROT COMPUTATION WITH HIGH PRECISION =====\n\nfn getCurrentView() -> View {\n    let t = activationContext.timestep;\n    \n    // High-precision zoom calculation\n    let zoom_factor = exp(-t * ZOOM_SPEED);\n    let zoom = ds_mul_f(INITIAL_ZOOM, 0.0, zoom_factor);\n    \n    // Smooth pan with high precision\n    let smoothT = 1.0 - exp(-t * PAN_SPEED);\n    let rawCenterX = ds_mix(INIT_CENTER.x, 0.0, TARGET_CENTER.x, 0.0, smoothT);\n    let rawCenterY = ds_mix(INIT_CENTER.y, 0.0, TARGET_CENTER.y, 0.0, smoothT);\n    \n    // Split into integer tile + fraction with high precision\n    let floorX = ds_floor(rawCenterX.x, rawCenterX.y);\n    let floorY = ds_floor(rawCenterY.x, rawCenterY.y);\n    \n    var tileX = ds_to_int(floorX.x, floorX.y);\n    var tileY = ds_to_int(floorY.x, floorY.y);\n    var fracX = ds_fract(rawCenterX.x, rawCenterX.y);\n    var fracY = ds_fract(rawCenterY.x, rawCenterY.y);\n    \n    // Recenter X with high precision\n    let fracX_f = ds_to_float(fracX.x, fracX.y);\n    if (fracX_f < SAFE_MIN) {\n        tileX -= 1;\n        fracX = ds_add(fracX.x, fracX.y, 1.0, 0.0);\n    } else if (fracX_f > SAFE_MAX) {\n        tileX += 1;\n        fracX = ds_sub(fracX.x, fracX.y, 1.0, 0.0);\n    }\n    \n    // Recenter Y with high precision\n    let fracY_f = ds_to_float(fracY.x, fracY.y);\n    if (fracY_f < SAFE_MIN) {\n        tileY -= 1;\n        fracY = ds_add(fracY.x, fracY.y, 1.0, 0.0);\n    } else if (fracY_f > SAFE_MAX) {\n        tileY += 1;\n        fracY = ds_sub(fracY.x, fracY.y, 1.0, 0.0);\n    }\n    \n    return View(\n        zoom.x, zoom.y,\n        vec2<u32>(u32(tileX), u32(tileY)),\n        vec2<f32>(fracX.x, fracY.x),\n        vec2<f32>(fracX.y, fracY.y)\n    );\n}\n\n// High-precision complex multiplication\n// (a_re + a_im*i) * (b_re + b_im*i) = (a_re*b_re - a_im*b_im) + (a_re*b_im + a_im*b_re)*i\nfn complex_ds_mul(\n    a_re_hi: f32, a_re_lo: f32, a_im_hi: f32, a_im_lo: f32,\n    b_re_hi: f32, b_re_lo: f32, b_im_hi: f32, b_im_lo: f32\n) -> vec4<f32> {\n    let term1 = ds_mul(a_re_hi, a_re_lo, b_re_hi, b_re_lo);\n    let term2 = ds_mul(a_im_hi, a_im_lo, b_im_hi, b_im_lo);\n    let re_part = ds_sub(term1.x, term1.y, term2.x, term2.y);\n    \n    let term3 = ds_mul(a_re_hi, a_re_lo, b_im_hi, b_im_lo);\n    let term4 = ds_mul(a_im_hi, a_im_lo, b_re_hi, b_re_lo);\n    let im_part = ds_add(term3.x, term3.y, term4.x, term4.y);\n    \n    return vec4<f32>(re_part.x, re_part.y, im_part.x, im_part.y);\n}\n\n// High-precision complex addition\nfn complex_ds_add(\n    a_re_hi: f32, a_re_lo: f32, a_im_hi: f32, a_im_lo: f32,\n    b_re_hi: f32, b_re_lo: f32, b_im_hi: f32, b_im_lo: f32\n) -> vec4<f32> {\n    let re_part = ds_add(a_re_hi, a_re_lo, b_re_hi, b_re_lo);\n    let im_part = ds_add(a_im_hi, a_im_lo, b_im_hi, b_im_lo);\n    return vec4<f32>(re_part.x, re_part.y, im_part.x, im_part.y);\n}\n\n// High-precision magnitude squared\nfn complex_ds_mag_sq(re_hi: f32, re_lo: f32, im_hi: f32, im_lo: f32) -> f32 {\n    let re_sq = ds_mul(re_hi, re_lo, re_hi, re_lo);\n    let im_sq = ds_mul(im_hi, im_lo, im_hi, im_lo);\n    let mag_sq = ds_add(re_sq.x, re_sq.y, im_sq.x, im_sq.y);\n    return ds_to_float(mag_sq.x, mag_sq.y);\n}\n\nfn pixelToComplexDS(gid: vec3<u32>) -> vec4<f32> {\n    let view = getCurrentView();\n    \n    // Pixel coords centered at (512,512)\n    let px = f32(gid.x) - 512.0;\n    let py = f32(gid.y) - 512.0;\n    \n    // High-precision local position calculation\n    let px_ds = ds_mul_f(view.zoom_hi, view.zoom_lo, px);\n    let py_ds = ds_mul_f(view.zoom_hi, view.zoom_lo, py);\n    \n    let localPosX = ds_add(px_ds.x, px_ds.y, view.centerFrac_hi.x, view.centerFrac_lo.x);\n    let localPosY = ds_add(py_ds.x, py_ds.y, view.centerFrac_hi.y, view.centerFrac_lo.y);\n    \n    // Compute any additional tile offset\n    let offsetX = ds_to_int(ds_floor(localPosX.x, localPosX.y).x, ds_floor(localPosX.x, localPosX.y).y);\n    let offsetY = ds_to_int(ds_floor(localPosY.x, localPosY.y).x, ds_floor(localPosY.x, localPosY.y).y);\n    \n    let fracX = ds_fract(localPosX.x, localPosX.y);\n    let fracY = ds_fract(localPosY.x, localPosY.y);\n    \n    // Final integer tile indices\n    let baseX = i32(view.centerTile.x);\n    let baseY = i32(view.centerTile.y);\n    let idxX = baseX + offsetX;\n    let idxY = baseY + offsetY;\n    \n    // Assemble high-precision complex number\n    let final_re = ds_add(f32(idxX), 0.0, fracX.x, fracX.y);\n    let final_im = ds_add(f32(idxY), 0.0, fracY.x, fracY.y);\n    \n    return vec4<f32>(final_re.x, final_re.y, final_im.x, final_im.y);\n}\n\nfn mandelbrotDS(c_re_hi: f32, c_re_lo: f32, c_im_hi: f32, c_im_lo: f32) -> f32 {\n    var z_re_hi = 0.0;\n    var z_re_lo = 0.0;\n    var z_im_hi = 0.0;\n    var z_im_lo = 0.0;\n    \n    var i: u32 = 0u;\n    \n    for (; i < MAX_ITERATIONS; i++) {\n        let mag_sq = complex_ds_mag_sq(z_re_hi, z_re_lo, z_im_hi, z_im_lo);\n        if (mag_sq > ESCAPE_RADIUS_SQUARED) { \n            break; \n        }\n        \n        // z = z*z + c\n        let z_squared = complex_ds_mul(z_re_hi, z_re_lo, z_im_hi, z_im_lo, \n                                       z_re_hi, z_re_lo, z_im_hi, z_im_lo);\n        let z_new = complex_ds_add(z_squared.x, z_squared.y, z_squared.z, z_squared.w,\n                                   c_re_hi, c_re_lo, c_im_hi, c_im_lo);\n        \n        z_re_hi = z_new.x;\n        z_re_lo = z_new.y;\n        z_im_hi = z_new.z;\n        z_im_lo = z_new.w;\n    }\n    \n    if (i == MAX_ITERATIONS) { \n        return 0.0; \n    }\n    \n    // Smooth coloring with high precision\n    let final_mag_sq = complex_ds_mag_sq(z_re_hi, z_re_lo, z_im_hi, z_im_lo);\n    let mu = f32(i) + 1.0 - log2(log2(final_mag_sq) * 0.5);\n    return mu * 0.08;\n}\n\nfn activation(x: f32) -> f32 {\n    let c = pixelToComplexDS(activationContext.gid);\n    let m = mandelbrotDS(c.x, c.y, c.z, c.w);\n    \n    // RGB phase offsets\n    if (activationContext.channel == 0u) {\n        return sin(m) * 0.5 + 0.5;\n    } else if (activationContext.channel == 1u) {\n        return sin(m + 2.094) * 0.5 + 0.5;\n    } else {\n        return sin(m + 4.189) * 0.5 + 0.5;\n    }\n}",
  "normalize": true
}