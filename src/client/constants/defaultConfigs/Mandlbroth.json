{
  "weights": [
    [
      [
        [
          0,
          0,
          0,
          0,
          0
        ],
        [
          0,
          0,
          0,
          0,
          0
        ],
        [
          0,
          0,
          0,
          0,
          0
        ],
        [
          0,
          0,
          0,
          0,
          0
        ],
        [
          0,
          0,
          0,
          0,
          0
        ]
      ],
      [
        [
          0,
          0,
          0,
          0,
          0
        ],
        [
          0,
          0,
          0,
          0,
          0
        ],
        [
          0,
          0,
          0,
          0,
          0
        ],
        [
          0,
          0,
          0,
          0,
          0
        ],
        [
          0,
          0,
          0,
          0,
          0
        ]
      ],
      [
        [
          0,
          0,
          0,
          0,
          0
        ],
        [
          0,
          0,
          0,
          0,
          0
        ],
        [
          0,
          0,
          0,
          0,
          0
        ],
        [
          0,
          0,
          0,
          0,
          0
        ],
        [
          0,
          0,
          0,
          0,
          0
        ]
      ]
    ],
    [
      [
        [
          0,
          0,
          0,
          0,
          0
        ],
        [
          0,
          0,
          0,
          0,
          0
        ],
        [
          0,
          0,
          0,
          0,
          0
        ],
        [
          0,
          0,
          0,
          0,
          0
        ],
        [
          0,
          0,
          0,
          0,
          0
        ]
      ],
      [
        [
          0,
          0,
          0,
          0,
          0
        ],
        [
          0,
          0,
          0,
          0,
          0
        ],
        [
          0,
          0,
          0,
          0,
          0
        ],
        [
          0,
          0,
          0,
          0,
          0
        ],
        [
          0,
          0,
          0,
          0,
          0
        ]
      ],
      [
        [
          0,
          0,
          0,
          0,
          0
        ],
        [
          0,
          0,
          0,
          0,
          0
        ],
        [
          0,
          0,
          0,
          0,
          0
        ],
        [
          0,
          0,
          0,
          0,
          0
        ],
        [
          0,
          0,
          0,
          0,
          0
        ]
      ]
    ],
    [
      [
        [
          0,
          0,
          0,
          0,
          0
        ],
        [
          0,
          0,
          0,
          0,
          0
        ],
        [
          0,
          0,
          0,
          0,
          0
        ],
        [
          0,
          0,
          0,
          0,
          0
        ],
        [
          0,
          0,
          0,
          0,
          0
        ]
      ],
      [
        [
          0,
          0,
          0,
          0,
          0
        ],
        [
          0,
          0,
          0,
          0,
          0
        ],
        [
          0,
          0,
          0,
          0,
          0
        ],
        [
          0,
          0,
          0,
          0,
          0
        ],
        [
          0,
          0,
          0,
          0,
          0
        ]
      ],
      [
        [
          0,
          0,
          0,
          0,
          0
        ],
        [
          0,
          0,
          0,
          0,
          0
        ],
        [
          0,
          0,
          0,
          0,
          0
        ],
        [
          0,
          0,
          0,
          0,
          0
        ],
        [
          0,
          0,
          0,
          0,
          0
        ]
      ]
    ]
  ],
  "activationCode": "// Quad‑float emulation (≈212 bits of precision) on top of f32s\n\nconst MAX_ITERATIONS: u32       = 1000u;\nconst ESCAPE_RADIUS_SQUARED: f32 = 4.0;\nconst ZOOM_SPEED: f32            = 0.0025;\nconst INITIAL_ZOOM: f32          = 0.01;\nconst PAN_SPEED: f32             = 0.01;\n\n// Initial + target pan centers\nconst INIT_CENTER: vec2<f32>   = vec2<f32>(0.0, 0.0);\nconst TARGET_CENTER: vec2<f32> = vec2<f32>(-0.039016, 0.985599);\n\nstruct f128 {\n    x0: f32,  // most significant\n    x1: f32,\n    x2: f32,\n    x3: f32  // least significant\n};\n\n// —— Core error‑free transforms ——\n\nfn two_sum(a: f32, b: f32) -> vec2<f32> {\n    let s  = a + b;\n    let bb = s - a;\n    let err = (a - (s - bb)) + (b - bb);\n    return vec2<f32>(s, err);\n}\n\nfn renormalize4(v: vec4<f32>) -> f128 {\n    let s0 = two_sum(v.x, v.y);\n    let s1 = two_sum(s0.y, v.z);\n    let s2 = two_sum(s1.y, v.w);\n    return f128(s0.x, s1.x, s2.x, s2.y);\n}\n\n// —— Basic f128 arithmetic ——\n\nfn f128_from_f32(a: f32) -> f128 {\n    return f128(a, 0.0, 0.0, 0.0);\n}\n\nfn f128_add(a: f128, b: f128) -> f128 {\n    let s0 = two_sum(a.x0, b.x0);\n    let s1 = two_sum(a.x1, b.x1);\n    let s2 = two_sum(a.x2, b.x2);\n    let s3 = two_sum(a.x3, b.x3);\n    let raw = vec4<f32>(\n        s0.x,\n        s0.y + s1.x,\n        s1.y + s2.x,\n        s2.y + s3.x + s3.y\n    );\n    return renormalize4(raw);\n}\n\nfn f128_sub(a: f128, b: f128) -> f128 {\n    return f128_add(a, f128(-b.x0, -b.x1, -b.x2, -b.x3));\n}\n\nfn f128_mul(a: f128, b: f128) -> f128 {\n    var p = array<f32, 10>(\n        a.x0*b.x0,\n        a.x0*b.x1 + a.x1*b.x0,\n        a.x0*b.x2 + a.x1*b.x1 + a.x2*b.x0,\n        a.x0*b.x3 + a.x1*b.x2 + a.x2*b.x1 + a.x3*b.x0,\n        a.x1*b.x3 + a.x2*b.x2 + a.x3*b.x1,\n        a.x2*b.x3 + a.x3*b.x2,\n        a.x3*b.x3,\n        0.0,\n        0.0,\n        0.0\n    );\n    var acc = vec4<f32>(p[0], p[1], p[2], p[3]);\n    for (var i: u32 = 4u; i < 7u; i = i + 1u) {\n        let t = two_sum(acc.x, p[i]);\n        acc = vec4<f32>(t.x, t.y + acc.y, acc.z, acc.w);\n        let n = renormalize4(acc);\n        acc = vec4<f32>(n.x0, n.x1, n.x2, n.x3);\n    }\n    return renormalize4(acc);\n}\n\nfn f128_mul_f(a: f128, b: f32) -> f128 {\n    let hi = a.x0 * b;\n    let lo = (a.x1 + a.x2 + a.x3) * b;\n    return renormalize4(vec4<f32>(hi, lo, 0.0, 0.0));\n}\n\n// —— Conversions, floor/fract, magnitude ——\n\nfn f128_to_f32(a: f128) -> f32 {\n    return a.x0;\n}\n\nfn f128_to_int(a: f128) -> i32 {\n    return i32(a.x0);\n}\n\nfn f128_floor(a: f128) -> f128 {\n    let f0 = floor(a.x0);\n    return f128(f0, 0.0, 0.0, 0.0);\n}\n\nfn f128_fract(a: f128) -> f128 {\n    return f128_sub(a, f128_floor(a));\n}\n\n// —— Complex quad‑float ——\n\nfn complex_f128_mul(a: f128, b: f128, c: f128, d: f128) -> vec4<f32> {\n    // (a+bi)*(c+di)\n    let ac = f128_mul(a, c);\n    let bd = f128_mul(b, d);\n    let re = f128_sub(ac, bd);\n    let ad = f128_mul(a, d);\n    let bc = f128_mul(b, c);\n    let im = f128_add(ad, bc);\n    return vec4<f32>(re.x0, re.x1, im.x0, im.x1);\n}\n\nfn complex_f128_add(\n    realA: f128, realB: f128,\n    imagA: f128, imagB: f128\n) -> vec4<f32> {\n    let re = f128_add(realA, realB);\n    let im = f128_add(imagA, imagB);\n    return vec4<f32>(re.x0, re.x1, im.x0, im.x1);\n}\n\nfn complex_f128_mag_sq(a: f128, b: f128) -> f128 {\n    let aa = f128_mul(a, a);\n    let bb = f128_mul(b, b);\n    return f128_add(aa, bb);\n}\n\n// —— View + pixel mapping —— \n\nstruct View {\n    zoom:      f128,\n    centerTile: vec2<u32>,\n    centerFracX: f128,\n    centerFracY: f128\n};\n\nfn getView() -> View {\n    let t = activationContext.timestep;\n    let zoomF = exp(-t * ZOOM_SPEED);\n    let zoom = f128_mul_f(f128_from_f32(INITIAL_ZOOM), zoomF);\n\n    let smoothT = 1.0 - exp(-t * PAN_SPEED);\n    let cx = f128_add(\n        f128_mul_f(f128_from_f32(TARGET_CENTER.x - INIT_CENTER.x), smoothT),\n        f128_from_f32(INIT_CENTER.x)\n    );\n    let cy = f128_add(\n        f128_mul_f(f128_from_f32(TARGET_CENTER.y - INIT_CENTER.y), smoothT),\n        f128_from_f32(INIT_CENTER.y)\n    );\n\n    let fx = f128_floor(cx);\n    let fy = f128_floor(cy);\n    let tileX = u32(f128_to_int(fx));\n    let tileY = u32(f128_to_int(fy));\n    let fracX = f128_fract(cx);\n    let fracY = f128_fract(cy);\n\n    return View(zoom, vec2<u32>(tileX, tileY), fracX, fracY);\n}\n\nstruct ComplexF128 { re: f128, im: f128 }\n\nfn pixelToComplexF128(gid: vec3<u32>) -> ComplexF128 {\n    let view = getView();\n    let uv = vec2<f32>(f32(gid.x) - 512.0, f32(gid.y) - 512.0);\n\n    let dsx = f128_mul_f(view.zoom, uv.x);\n    let dsy = f128_mul_f(view.zoom, uv.y);\n\n    let posX = f128_add(dsx, view.centerFracX);\n    let posY = f128_add(dsy, view.centerFracY);\n\n    let ix = f128_floor(posX);\n    let iy = f128_floor(posY);\n    let idx = i32(view.centerTile.x) + f128_to_int(ix);\n    let idy = i32(view.centerTile.y) + f128_to_int(iy);\n\n    let fx = f128_fract(posX);\n    let fy = f128_fract(posY);\n\n    let re = f128_add(f128_from_f32(f32(idx)), fx);\n    let im = f128_add(f128_from_f32(f32(idy)), fy);\n\n    return ComplexF128(re, im);\n}\n\n// —— Mandelbrot loop using full quad‑float ——\n\nfn mandelbrotF128(c_re: f128, c_im: f128) -> f32 {\n    var z_re = f128_from_f32(0.0);\n    var z_im = f128_from_f32(0.0);\n    var i: u32 = 0u;\n\n    loop {\n        if (i >= MAX_ITERATIONS) { break; }\n        let mag2 = complex_f128_mag_sq(z_re, z_im);\n        if (f128_to_f32(mag2) > ESCAPE_RADIUS_SQUARED) { break; }\n\n        let sq = complex_f128_mul(z_re, z_im, z_re, z_im);\n\n        // add c:\n        let tmp = complex_f128_add(\n            // realA, realB\n            f128(sq.x, sq.y, 0.0, 0.0),  c_re,\n            // imagA, imagB\n            f128(sq.z, sq.w, 0.0, 0.0),  c_im\n        );\n\n        // ── CORRECT RECONSTRUCTION ──\n        z_re = f128(tmp.x, tmp.y, 0.0, 0.0);\n        z_im = f128(tmp.z, tmp.w, 0.0, 0.0);\n\n        i = i + 1u;\n    }\n\n    if (i == MAX_ITERATIONS) {\n        return 0.0;\n    }\n    let finalMag2 = complex_f128_mag_sq(z_re, z_im);\n    let mu = f32(i) + 1.0 - log2(log2(f128_to_f32(finalMag2)) * 0.5);\n    return mu * 0.08;\n}\n\n// —— Entry point unchanged —— \n\nfn activation(x: f32) -> f32 {\n    let c = pixelToComplexF128(activationContext.gid);\n    let m = mandelbrotF128(c.re, c.im);\n\n    if (activationContext.channel == 0u) {\n        return sin(m) * 0.5 + 0.5;\n    } else if (activationContext.channel == 1u) {\n        return sin(m + 2.094) * 0.5 + 0.5;\n    } else {\n        return sin(m + 4.189) * 0.5 + 0.5;\n    }\n}\n",
  "normalize": true,
  "computeKernel": false
}