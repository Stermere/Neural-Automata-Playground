{
  "weights": [
    [
      [
        [
          1,
          1,
          1,
          1,
          -1
        ],
        [
          1,
          1,
          1,
          1,
          1
        ],
        [
          1,
          2,
          1,
          1,
          1
        ],
        [
          1,
          1,
          1,
          1,
          1
        ],
        [
          1,
          1,
          1,
          1,
          1
        ]
      ],
      [
        [
          -1,
          0,
          0,
          0,
          0
        ],
        [
          0,
          0,
          0,
          0,
          0
        ],
        [
          0,
          0,
          1,
          0,
          0
        ],
        [
          0,
          0,
          0,
          0,
          0
        ],
        [
          1,
          0,
          0,
          0,
          1
        ]
      ],
      [
        [
          0,
          0,
          0,
          0,
          0
        ],
        [
          0,
          0,
          0,
          0,
          0
        ],
        [
          0,
          0,
          -1,
          0,
          0
        ],
        [
          0,
          0,
          0,
          0,
          0
        ],
        [
          -1,
          0,
          0,
          0,
          1
        ]
      ]
    ],
    [
      [
        [
          0,
          -2,
          0,
          0,
          1
        ],
        [
          -2,
          5,
          0,
          0,
          0
        ],
        [
          0,
          0,
          6,
          0,
          0
        ],
        [
          0,
          0,
          0,
          1,
          0
        ],
        [
          0,
          0,
          0,
          0,
          -1
        ]
      ],
      [
        [
          0,
          0,
          0,
          0,
          0
        ],
        [
          0,
          0,
          0,
          0,
          0
        ],
        [
          0,
          0,
          0,
          0,
          0
        ],
        [
          0,
          0,
          0,
          0,
          0
        ],
        [
          0,
          0,
          0,
          0,
          0
        ]
      ],
      [
        [
          1,
          0,
          0,
          0,
          0
        ],
        [
          0,
          1,
          -1,
          1,
          0
        ],
        [
          0,
          1,
          1,
          1,
          0
        ],
        [
          0,
          0,
          -1,
          1,
          0
        ],
        [
          0,
          0,
          0,
          0,
          1
        ]
      ]
    ],
    [
      [
        [
          0,
          0,
          0,
          0,
          0
        ],
        [
          0,
          7,
          0,
          7,
          0
        ],
        [
          0,
          0,
          -2.5,
          0,
          0
        ],
        [
          0,
          0,
          0,
          0,
          0
        ],
        [
          0,
          0,
          0,
          0,
          0
        ]
      ],
      [
        [
          -1,
          -1,
          -1,
          -1,
          0
        ],
        [
          -1,
          0,
          0,
          0,
          0
        ],
        [
          -1,
          0,
          3.9,
          0,
          0
        ],
        [
          0,
          0,
          0,
          1,
          1
        ],
        [
          1,
          0,
          0,
          1,
          -1
        ]
      ],
      [
        [
          0,
          0,
          0,
          0,
          -2
        ],
        [
          0,
          0,
          -1,
          0,
          0
        ],
        [
          0,
          -1,
          1,
          -1,
          0
        ],
        [
          0,
          0,
          -1,
          0,
          0
        ],
        [
          0,
          0,
          0,
          0,
          3
        ]
      ]
    ]
  ],
  "activationCode": "// spatial frequency: maps pixel coords → noise space. smaller → broad/slow-changing blobs,\n// larger → fine detail. (affects feature size)\nconst NOISE_SCALE: f32 = 302.7; @variable 10 500     \n// temporal speed multiplier: multiplies activationContext.timestep when sampling noise.\n// larger → faster animation; tune relative to your timestep units.\nconst TIME_SPEED: f32 = 513.37; @variable 1 1000     \n// fBm octaves: number of noise layers summed. integer-valued (use whole numbers).\n// more octaves → richer detail but higher cost.\nconst NOISE_OCTAVES: f32 = 8; @variable 1 8  \n// amplitude falloff per octave: lower → smoother,\n// higher → more high-frequency energy. typical: 0.3–0.7.\nconst PERSISTENCE: f32 = 0.31; @variable 0.0 1.0   \n// frequency multiplier per octave: >1 increases frequency each octave.\n// common: ~1.5–3.0 (higher → more rapid detail growth).\nconst LACUNARITY: f32 = 1; @variable 1.0 4.0 \n// strength of noise effect on cell state: scales noise contribution \n// (multiplied by tanh(x) in activation). larger → stronger updates; watch clamping.\nconst BASE_RATE: f32 = 0.08; @variable 0.0 2.0   \n// max influence of the noise\nconst MAX_INFLUENCE: f32 = 0.8; @variable 0.1 1.0\n\n// --- helper functions ---\nfn fade(t: vec3<f32>) -> vec3<f32> {\n  return t * t * t * (t * (t * 6.0 - 15.0) + 10.0);\n}\n\nfn lerp(a: f32, b: f32, t: f32) -> f32 {\n  return a + t * (b - a);\n}\n\n// A deterministic scalar hash from a 3D position -> [0,1)\nfn hash(p: vec3<f32>) -> f32 {\n  // constants chosen for nice distribution\n  return fract(sin(dot(p, vec3<f32>(127.1, 311.7, 74.7))) * 43758.5453123);\n}\n\n// Produce a pseudo-random normalized gradient vector at integer lattice point p\nfn grad3(p: vec3<f32>) -> vec3<f32> {\n  // create three correlated random scalars and remap to [-1,1]\n  let r1 = hash(p);\n  let r2 = hash(p + vec3<f32>(1.3, 7.1, 4.7));\n  let r3 = hash(p + vec3<f32>(5.2, 2.8, 9.4));\n  let g = vec3<f32>(r1 * 2.0 - 1.0, r2 * 2.0 - 1.0, r3 * 2.0 - 1.0);\n  // normalize to approximate a gradient direction\n  return normalize(g);\n}\n\n// Classic Perlin-style 3D gradient noise returning roughly in [-1, 1]\nfn perlin3(p: vec3<f32>) -> f32 {\n  let Pi = floor(p);\n  let Pf = fract(p);\n  let u = fade(Pf);\n\n  // sample gradients at 8 cube corners and dot with offset vectors\n  let g000 = grad3(Pi + vec3<f32>(0.0, 0.0, 0.0));\n  let g100 = grad3(Pi + vec3<f32>(1.0, 0.0, 0.0));\n  let g010 = grad3(Pi + vec3<f32>(0.0, 1.0, 0.0));\n  let g110 = grad3(Pi + vec3<f32>(1.0, 1.0, 0.0));\n  let g001 = grad3(Pi + vec3<f32>(0.0, 0.0, 1.0));\n  let g101 = grad3(Pi + vec3<f32>(1.0, 0.0, 1.0));\n  let g011 = grad3(Pi + vec3<f32>(0.0, 1.0, 1.0));\n  let g111 = grad3(Pi + vec3<f32>(1.0, 1.0, 1.0));\n\n  let d000 = dot(g000, Pf - vec3<f32>(0.0, 0.0, 0.0));\n  let d100 = dot(g100, Pf - vec3<f32>(1.0, 0.0, 0.0));\n  let d010 = dot(g010, Pf - vec3<f32>(0.0, 1.0, 0.0));\n  let d110 = dot(g110, Pf - vec3<f32>(1.0, 1.0, 0.0));\n  let d001 = dot(g001, Pf - vec3<f32>(0.0, 0.0, 1.0));\n  let d101 = dot(g101, Pf - vec3<f32>(1.0, 0.0, 1.0));\n  let d011 = dot(g011, Pf - vec3<f32>(0.0, 1.0, 1.0));\n  let d111 = dot(g111, Pf - vec3<f32>(1.0, 1.0, 1.0));\n\n  // trilinear (smooth) interpolation\n  let nx00 = lerp(d000, d100, u.x);\n  let nx10 = lerp(d010, d110, u.x);\n  let nx01 = lerp(d001, d101, u.x);\n  let nx11 = lerp(d011, d111, u.x);\n\n  let nxy0 = lerp(nx00, nx10, u.y);\n  let nxy1 = lerp(nx01, nx11, u.y);\n\n  return lerp(nxy0, nxy1, u.z);\n}\n\n// Fractal Brownian Motion wrapper (fBm) using perlin3\nfn perlinFBM(p: vec3<f32>) -> f32 {\n  var amplitude: f32 = 1.0;\n  var frequency: f32 = 1.0;\n  var sum: f32 = 0.0;\n  var maxAmp: f32 = 0.0;\n\n  var i: u32 = 0u;\n  loop {\n    if (i >= u32(NOISE_OCTAVES)) { break; }\n    sum = sum + perlin3(p * frequency) * amplitude;\n    maxAmp = maxAmp + amplitude;\n    amplitude = amplitude * PERSISTENCE;\n    frequency = frequency * LACUNARITY;\n    i = i + 1u;\n  }\n\n  // normalize to roughly [-1,1]\n  return sum / maxAmp;\n}\n\n// --- Define Whatever function here using the noise ---\nfn activation(x: f32) -> f32 {\n  let px = f32(activationContext.gid.x) / NOISE_SCALE;\n  let py = f32(activationContext.gid.y) / NOISE_SCALE;\n  let time = activationContext.timestep / TIME_SPEED;\n\n  // animated 3D point: (x, y, t)\n  let raw = perlinFBM(vec3<f32>(px, py, time));\n\n  // perlin3/perlinFBM returns roughly in [-1,1] already, but clamp/scale if needed\n  let signedNoise = clamp(raw, -1.0, 1.0);\n\n  // use signedNoise in place of your previous distFactor\n  return clamp(\n    activationContext.cellState[activationContext.channel] + BASE_RATE * (signedNoise * MAX_INFLUENCE) * tanh(x),\n    0.0,\n    1.0\n  );\n}",
  "normalize": true
}