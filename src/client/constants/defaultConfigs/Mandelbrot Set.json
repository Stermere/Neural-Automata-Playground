{
  "weights": [
    [
      [
        [
          0,
          0,
          0,
          0,
          0
        ],
        [
          0,
          0,
          0,
          0,
          0
        ],
        [
          0,
          0,
          0,
          0,
          0
        ],
        [
          0,
          0,
          0,
          0,
          0
        ],
        [
          0,
          0,
          0,
          0,
          0
        ]
      ],
      [
        [
          0,
          0,
          0,
          0,
          0
        ],
        [
          0,
          0,
          0,
          0,
          0
        ],
        [
          0,
          0,
          0,
          0,
          0
        ],
        [
          0,
          0,
          0,
          0,
          0
        ],
        [
          0,
          0,
          0,
          0,
          0
        ]
      ],
      [
        [
          0,
          0,
          0,
          0,
          0
        ],
        [
          0,
          0,
          0,
          0,
          0
        ],
        [
          0,
          0,
          0,
          0,
          0
        ],
        [
          0,
          0,
          0,
          0,
          0
        ],
        [
          0,
          0,
          0,
          0,
          0
        ]
      ]
    ],
    [
      [
        [
          0,
          0,
          0,
          0,
          0
        ],
        [
          0,
          0,
          0,
          0,
          0
        ],
        [
          0,
          0,
          0,
          0,
          0
        ],
        [
          0,
          0,
          0,
          0,
          0
        ],
        [
          0,
          0,
          0,
          0,
          0
        ]
      ],
      [
        [
          0,
          0,
          0,
          0,
          0
        ],
        [
          0,
          0,
          0,
          0,
          0
        ],
        [
          0,
          0,
          0,
          0,
          0
        ],
        [
          0,
          0,
          0,
          0,
          0
        ],
        [
          0,
          0,
          0,
          0,
          0
        ]
      ],
      [
        [
          0,
          0,
          0,
          0,
          0
        ],
        [
          0,
          0,
          0,
          0,
          0
        ],
        [
          0,
          0,
          0,
          0,
          0
        ],
        [
          0,
          0,
          0,
          0,
          0
        ],
        [
          0,
          0,
          0,
          0,
          0
        ]
      ]
    ],
    [
      [
        [
          0,
          0,
          0,
          0,
          0
        ],
        [
          0,
          0,
          0,
          0,
          0
        ],
        [
          0,
          0,
          0,
          0,
          0
        ],
        [
          0,
          0,
          0,
          0,
          0
        ],
        [
          0,
          0,
          0,
          0,
          0
        ]
      ],
      [
        [
          0,
          0,
          0,
          0,
          0
        ],
        [
          0,
          0,
          0,
          0,
          0
        ],
        [
          0,
          0,
          0,
          0,
          0
        ],
        [
          0,
          0,
          0,
          0,
          0
        ],
        [
          0,
          0,
          0,
          0,
          0
        ]
      ],
      [
        [
          0,
          0,
          0,
          0,
          0
        ],
        [
          0,
          0,
          0,
          0,
          0
        ],
        [
          0,
          0,
          0,
          0,
          0
        ],
        [
          0,
          0,
          0,
          0,
          0
        ],
        [
          0,
          0,
          0,
          0,
          0
        ]
      ]
    ]
  ],
  "activationCode": "// Mandelbrot Set renderer using double-float (f64) arithmetic\n\nconst MAX_ITERATIONS: u32 = 1000u;\nconst ESCAPE_RADIUS_SQUARED: f32 = 4.0;\nconst ZOOM_SPEED: f32 = 0.01;\nconst INITIAL_ZOOM: f32 = 0.01;\nconst PAN_SPEED: f32 = 0.5;\n\n// —— True “double” (≈53 bits mantissa + 11 bits exponent) emulation on top of f32 ——\n\nstruct f64 {\n    hi: f32,\n    lo: f32,\n}\n\n// High-precision center coordinates (TARGET_CENTER)\n// real_part = -0.7746806106269039\n// imag_part = -0.1374168856037867\nconst TARGET_CENTER: f64 = f64(-0.77468061, 3.84453180e-09);\nconst TARGET_CENTER_IM: f64 = f64(-0.13741688, -1.30069377e-09);\n\nconst INIT_CENTER: f64 = f64(0.0, 0.0);\n\n// —— Core error-free transforms ——\n\nfn two_sum(a: f32, b: f32) -> vec2<f32> {\n    let s = a + b;\n    let bb = s - a;\n    let err = (a - (s - bb)) + (b - bb);\n    return vec2<f32>(s, err);\n}\n\nfn split(a: f32) -> vec2<f32> {\n    let c = 8193.0 * a;\n    let hi = c - (c - a);\n    let lo = a - hi;\n    return vec2<f32>(hi, lo);\n}\n\nfn two_prod(a: f32, b: f32) -> vec2<f32> {\n    let p = a * b;\n    let sa = split(a);\n    let sb = split(b);\n    let err = ((sa.x * sb.x - p) + sa.x * sb.y + sa.y * sb.x) + sa.y * sb.y;\n    return vec2<f32>(p, err);\n}\n\nfn renormalize2(v: vec2<f32>) -> f64 {\n    let s = two_sum(v.x, v.y);\n    return f64(s.x, s.y);\n}\n\n// —— Basic f64 arithmetic ——\n\nfn f64_from_f32(a: f32) -> f64 {\n    return f64(a, 0.0);\n}\n\nfn f64_to_f32(a: f64) -> f32 {\n    return a.hi + a.lo;\n}\n\nfn f64_add(a: f64, b: f64) -> f64 {\n    let s = two_sum(a.hi, b.hi);\n    let t = a.lo + b.lo + s.y;\n    let r = two_sum(s.x, t);\n    return f64(r.x, r.y);\n}\n\nfn f64_sub(a: f64, b: f64) -> f64 {\n    return f64_add(a, f64(-b.hi, -b.lo));\n}\n\nfn f64_mul(a: f64, b: f64) -> f64 {\n    let p = two_prod(a.hi, b.hi);\n    let err = a.hi * b.lo + a.lo * b.hi;\n    let s = vec2<f32>(p.x, p.y + err);\n    return renormalize2(s);\n}\n\nfn f64_mul_f(a: f64, b: f32) -> f64 {\n    let p = two_prod(a.hi, b);\n    let err = a.lo * b;\n    let s = vec2<f32>(p.x, p.y + err);\n    return renormalize2(s);\n}\n\n// —— Conversions, floor/fract, magnitude ——\n\nfn f64_floor(a: f64) -> f64 {\n    let f = floor(a.hi);\n    return f64(f, 0.0);\n}\n\nfn f64_fract(a: f64) -> f64 {\n    return f64_sub(a, f64_floor(a));\n}\n\nfn f64_to_i32(a: f64) -> i32 {\n    return i32(f64_to_f32(a));\n}\n\n// —— Complex double-float ——\n\nstruct ComplexF64 {\n    re: f64,\n    im: f64\n}\n\nfn complex_f64_add(a: ComplexF64, b: ComplexF64) -> ComplexF64 {\n    return ComplexF64(\n        f64_add(a.re, b.re),\n        f64_add(a.im, b.im)\n    );\n}\n\nfn complex_f64_mul(a: ComplexF64, b: ComplexF64) -> ComplexF64 {\n    let ac = f64_mul(a.re, b.re);\n    let bd = f64_mul(a.im, b.im);\n    let re = f64_sub(ac, bd);\n\n    let ad = f64_mul(a.re, b.im);\n    let bc = f64_mul(a.im, b.re);\n    let im = f64_add(ad, bc);\n\n    return ComplexF64(re, im);\n}\n\nfn complex_f64_mag_sq(a: ComplexF64) -> f64 {\n    let aa = f64_mul(a.re, a.re);\n    let bb = f64_mul(a.im, a.im);\n    return f64_add(aa, bb);\n}\n\n// —— View + pixel mapping ——\n\nstruct ViewD {\n    zoom: f64,\n    centerTile: vec2<u32>,\n    centerFracX: f64,\n    centerFracY: f64\n};\n\nfn getViewD() -> ViewD {\n    let t = activationContext.timestep;\n    let zoomF = exp(-t * ZOOM_SPEED);\n    let zoom = f64_mul_f(f64_from_f32(INITIAL_ZOOM), zoomF);\n\n    let smoothT = 1.0 - exp(-t * PAN_SPEED);\n\n    let deltaX = f64_mul_f(f64_sub(TARGET_CENTER, INIT_CENTER), smoothT);\n    let deltaY = f64_mul_f(f64_sub(TARGET_CENTER_IM, INIT_CENTER), smoothT);\n    let cx = f64_add(INIT_CENTER, deltaX);\n    let cy = f64_add(INIT_CENTER, deltaY);\n\n    let fx = f64_floor(cx);\n    let fy = f64_floor(cy);\n    let tileX = u32(f64_to_i32(fx));\n    let tileY = u32(f64_to_i32(fy));\n    let fracX = f64_fract(cx);\n    let fracY = f64_fract(cy);\n\n    return ViewD(zoom, vec2<u32>(tileX, tileY), fracX, fracY);\n}\n\nfn pixelToComplexF64(gid: vec3<u32>) -> ComplexF64 {\n    let view = getViewD();\n    let uvx = f32(gid.x) - 512.0;\n    let uvy = f32(gid.y) - 512.0;\n\n    let dsx = f64_mul_f(view.zoom, uvx);\n    let dsy = f64_mul_f(view.zoom, uvy);\n\n    let posX = f64_add(dsx, view.centerFracX);\n    let posY = f64_add(dsy, view.centerFracY);\n\n    let ix = f64_floor(posX);\n    let iy = f64_floor(posY);\n    let idx = i32(view.centerTile.x) + f64_to_i32(ix);\n    let idy = i32(view.centerTile.y) + f64_to_i32(iy);\n\n    let fx = f64_fract(posX);\n    let fy = f64_fract(posY);\n\n    let re = f64_add(f64_from_f32(f32(idx)), fx);\n    let im = f64_add(f64_from_f32(f32(idy)), fy);\n\n    return ComplexF64(re, im);\n}\n\n// —— Mandelbrot iteration ——\n\nfn mandelbrotD(c: ComplexF64) -> f32 {\n    var z = ComplexF64(f64_from_f32(0.0), f64_from_f32(0.0));\n    var i: u32 = 0u;\n\n    loop {\n        if (i >= MAX_ITERATIONS) { break; }\n        let mag2 = complex_f64_mag_sq(z);\n        if (f64_to_f32(mag2) > ESCAPE_RADIUS_SQUARED) { break; }\n\n        let z2 = complex_f64_mul(z, z);\n        z = complex_f64_add(z2, c);\n        i = i + 1u;\n    }\n\n    if (i == MAX_ITERATIONS) {\n        return 0.0;\n    }\n    let finalMag2 = complex_f64_mag_sq(z);\n    let mu = f32(i) + 1.0 - log2(log2(f64_to_f32(finalMag2)) * 0.5);\n    return mu * 0.3;\n}\n\n// —— Entry point ——\n\nfn activation(x: f32) -> f32 {\n    let c = pixelToComplexF64(activationContext.gid);\n    let m = mandelbrotD(c);\n\n    // Inside the Mandelbrot set (did not escape)\n    if (m == 0.0) {\n        return 0.0;\n    }\n\n    // Outside: color based on escape time\n    if (activationContext.channel == 0u) {\n        return sin(m) * 0.5 + 0.5;\n    } else if (activationContext.channel == 1u) {\n        return sin(m + 2.094) * 0.5 + 0.5;\n    } else {\n        return sin(m + 4.189) * 0.5 + 0.5;\n    }\n}\n",
  "normalize": true
}